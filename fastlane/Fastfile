default_platform :ios
opt_out_usage
skip_docs

require 'json'
require 'net/http'
require 'xcodeproj'
import 'Sonarfile'
import 'Allurefile'

xcode_version = ENV['XCODE_VERSION'] || '26.1.1'
xcode_project = 'StreamChatSwiftUI.xcodeproj'
sdk_names = ['StreamChatSwiftUI']
github_repo = ENV['GITHUB_REPOSITORY'] || 'GetStream/stream-chat-swiftui'
derived_data_path = 'derived_data'
source_packages_path = 'spm_cache'
is_localhost = !is_ci
mock_server_driver_port = 4568
swift_environment_path = File.absolute_path('../Sources/StreamChatSwiftUI/Generated/SystemEnvironment+Version.swift')
@force_check = false

before_all do |lane|
  if is_ci
    setup_ci
    setup_git_config
    select_xcode(version: xcode_version) unless [:sonar_upload, :allure_launch, :allure_upload, :copyright, :merge_main].include?(lane)
  end
end

after_all do |lane|
  stop_mock_server if lane == :test_e2e_mock
end

# https://linear.app/stream/issue/IOS-630
private_lane :remove_swiftui_core_module_shadow do |options|
  Dir.glob("#{options[:output_directory]}/**/*.swiftinterface").each do |file|
    if File.file?(file)
      UI.important("Removing the SwiftUICore module's shadow at: #{file}...")
      File.write(file, File.read(file).gsub('SwiftUICore.', ''))
    end
  end
end

# Swift emits an invalid module interface when a public type has the same name as a module, see https://github.com/swiftlang/swift/issues/56573
private_lane :remove_stream_chat_module_shadow do |options|
  Dir.glob("#{options[:output_directory]}/**/*.swiftinterface") do |file|
    if File.file?(file)
      UI.important("Removing the StreamChat module's shadow at: #{file}...")
      File.write(file, File.read(file).gsub('StreamChat.', ''))
    end
  end
end

desc 'Release a new version'
lane :release do |options|
  extra_changes = lambda do |release_version|
    # Set the framework version in SystemEnvironment+Version.swift
    old_content = File.read(swift_environment_path)
    current_version = old_content[/version: String = "([^"]+)"/, 1]
    new_content = old_content.gsub(current_version, release_version)
    File.open(swift_environment_path, 'w') { |f| f.puts(new_content) }

    # Update sdk sizes
    Dir.chdir('fastlane') { update_img_shields_sdk_sizes }
  end

  check_unsafe_flags

  release_ios_sdk(
    version: options[:version],
    bump_type: options[:type],
    sdk_names: sdk_names,
    github_repo: github_repo,
    extra_changes: extra_changes,
    create_pull_request: true
  )
end

lane :merge_release do |options|
  merge_release_to_main(author: options[:author])
  sh('gh workflow run release-publish.yml --ref main')
end

lane :merge_main do
  merge_main_to_develop
  update_release_version_to_snapshot(file_path: swift_environment_path)
  ensure_git_branch(branch: 'develop')
  sh("git add #{swift_environment_path}")
  sh("git commit -m 'Update release version to snapshot'")
  sh('git push')
end

desc "Publish a new release to GitHub"
lane :publish_release do |options|
  release_version = get_sdk_version_from_environment
  UI.user_error!("Release #{release_version} has already been published.") if git_tag_exists(tag: release_version, remote: true)
  UI.user_error!('Release version cannot be empty') if release_version.to_s.empty?
  ensure_git_branch(branch: 'main')

  publish_ios_sdk(
    skip_git_status_check: false,
    version: release_version,
    sdk_names: sdk_names,
    github_repo: github_repo
  )

  update_spm(version: release_version)
end

lane :get_sdk_version_from_environment do
  File.read(swift_environment_path).match(/String\s+=\s+"([\d.]+).*"/)[1]
end

private_lane :appstore_api_key do
  @appstore_api_key ||= app_store_connect_api_key(
    key_id: 'MT3PRT8TB7',
    issuer_id: '69a6de96-0738-47e3-e053-5b8c7c11a4d1',
    key_content: ENV.fetch('APPSTORE_API_KEY', nil),
    in_house: false
  )
end

desc "Updates StreamChat dependency locally. Usage: `bundle exec fastlane update_stream_chat version:4.56.0`"
lane :update_stream_chat do |options|
  raise UI.user_error!('Provide a version.') unless options[:version]

  Dir.chdir('..') do
    file = 'Package.swift'
    current_stream_chat_version = File.read(file)[/stream-chat-swift\.git", from: "([\d.]+)"\)/, 1]
    File.write(file, File.read(file).gsub(/(stream-chat-swift\.git", from: ")[\d.]+"/, "\\1#{options[:version]}\""))

    file = 'StreamChatSwiftUI.xcodeproj/project.pbxproj'
    content = File.read(file)
    if content.include?("minimumVersion = #{current_stream_chat_version}")
      File.write(file, content.gsub("minimumVersion = #{current_stream_chat_version}", "minimumVersion = #{options[:version]}"))
    elsif content.include?('branch = develop')
      File.write(file, content.gsub('kind = branch', "minimumVersion = #{options[:version]}").gsub('branch = develop', 'kind = upToNextMajorVersion'))
    else
      UI.user_error!("Something went wrong after trying to modify #{file}.")
    end
  end

  pr_create(
    title: "Update StreamChat dependency to #{options[:version]}",
    base_branch: 'develop',
    head_branch: "ci/update-stream-chat-dependency-#{Time.now.to_i}",
    github_repo: github_repo
  )
end

desc "If `readonly: true` (by default), installs all Certs and Profiles necessary for development and ad-hoc.\nIf `readonly: false`, recreates all Profiles necessary for development and ad-hoc, updates them locally and remotely."
lane :match_me do |options|
  custom_match(
    api_key: appstore_api_key,
    app_identifier: ['io.getstream.iOS.DemoAppSwiftUI'],
    readonly: options[:readonly],
    register_device: options[:register_device]
  )
end

desc 'Builds the latest version of Demo app and uploads it to TestFlight'
lane :swiftui_testflight_build do |options|
  is_manual_upload = is_localhost || ENV['GITHUB_EVENT_NAME'] == 'workflow_dispatch'
  configuration = options[:configuration].to_s.empty? ? 'Release' : options[:configuration]

  match_me

  sdk_version = get_sdk_version_from_environment
  UI.important("[TestFlight] Uploading DemoApp version: #{sdk_version}")

  testflight_build(
    api_key: appstore_api_key,
    xcode_project: xcode_project,
    sdk_target: 'StreamChatSwiftUI',
    app_version: sdk_version,
    app_target: 'DemoAppSwiftUI',
    app_identifier: 'io.getstream.iOS.DemoAppSwiftUI',
    configuration: configuration,
    use_changelog: true,
    is_manual_upload: is_manual_upload
  )
end

desc 'Runs tests in Debug config'
lane :test_ui do |options|
  next unless is_check_required(sources: sources_matrix[:ui], force_check: @force_check)

  record_mode = options[:record].to_s == 'true'
  remove_snapshots if record_mode

  update_testplan_on_ci(path: 'StreamChatSwiftUITests/Tests/StreamChatSwiftUI.xctestplan')

  scan(
    project: xcode_project,
    scheme: 'StreamChatSwiftUI',
    testplan: 'StreamChatSwiftUI',
    configuration: 'Debug',
    clean: is_localhost,
    derived_data_path: derived_data_path,
    cloned_source_packages_path: source_packages_path,
    result_bundle: true,
    devices: options[:device],
    build_for_testing: options[:build_for_testing],
    skip_build: options[:skip_build],
    number_of_retries: options[:record].to_s.empty? ? 1 : nil,
    fail_build: !record_mode
  )

  if record_mode && is_ci
    png_files = git_status(ext: '.png').map { |_, png| png }.flatten
    next if png_files.empty?

    # Discard all files apart from the snapshots
    Dir.chdir('..') do
      png_files.each { |png| sh("git add #{png}") || true }
      sh('git restore .')
    end

    pr_create(
      title: '[CI] Snapshots',
      base_branch: current_branch,
      head_branch: "#{current_branch}-snapshots-#{Time.now.to_i}"
    )
  else
    slather unless options[:build_for_testing]
  end
end

lane :build_test_app_and_frameworks do
  scan(
    project: xcode_project,
    scheme: 'StreamChatSwiftUITestsApp',
    testplan: 'StreamChatSwiftUITestsApp',
    result_bundle: true,
    derived_data_path: derived_data_path,
    cloned_source_packages_path: source_packages_path,
    clean: is_localhost,
    build_for_testing: true
  )
end

lane :start_mock_server do |options|
  mock_server_repo = 'stream-chat-test-mock-server'
  stop_mock_server if is_localhost

  if options[:local_server]
    mock_server_repo = options[:local_server]
  else
    branch = options[:branch].to_s.empty? ? 'main' : options[:branch]
    sh("rm -rf #{mock_server_repo}") if File.directory?(mock_server_repo)
    sh("git clone -b #{branch} https://github.com/#{github_repo.split('/').first}/#{mock_server_repo}.git")
  end

  pids = sh("lsof -ti :#{mock_server_driver_port} || true", log: false).strip
  sh("kill -9 #{pids} || true", log: false) unless pids.empty?

  Dir.chdir(mock_server_repo) do
    FileUtils.mkdir_p('logs')
    sh("bundle exec ruby driver.rb #{mock_server_driver_port} > logs/driver.log 2>&1 &")
  end
end

lane :stop_mock_server do
  begin
    Net::HTTP.get_response(URI("http://localhost:#{mock_server_driver_port}/stop"))
  rescue StandardError
    nil
  end
end

desc 'Runs e2e ui tests using mock server in Debug config'
lane :test_e2e_mock do |options|
  next unless is_check_required(sources: sources_matrix[:e2e], force_check: @force_check)

  start_mock_server

  scan_options = {
    project: xcode_project,
    scheme: 'StreamChatSwiftUITestsApp',
    testplan: 'StreamChatSwiftUITestsApp',
    result_bundle: true,
    derived_data_path: derived_data_path,
    cloned_source_packages_path: source_packages_path,
    clean: is_localhost,
    test_without_building: options[:test_without_building],
    devices: options[:device],
    prelaunch_simulator: is_ci,
    number_of_retries: 3
  }

  if ENV['MATRIX_SIZE'] && options[:batch]
    products_dir = File.expand_path("../#{derived_data_path}/Build/Products")
    xctestrun = Dir.glob(File.expand_path("#{products_dir}/*.xctestrun")).first
    tests = retrieve_xctest_names(xctestrun: xctestrun).values.flatten
    slice_size = (tests.size / ENV['MATRIX_SIZE'].to_f).ceil
    only_testing = []
    tests.each_slice(slice_size) { |test| only_testing << test }
    only_testing_batch = only_testing[options[:batch].to_i]
    scan_options[:only_testing] = only_testing_batch
    UI.important("Tests in total: #{only_testing.flatten.size}. Running #{only_testing_batch.size} of them âŒ›ï¸")
  end

  begin
    scan(scan_options)
  rescue StandardError
    failed_tests = retreive_failed_tests
    UI.important("Re-running #{failed_tests.size} failed tests âŒ›ï¸")
    scan(scan_options.merge(only_testing: failed_tests))
  end
end

private_lane :retreive_failed_tests do
  report_path = 'test_output/report.junit'
  raise UI.user_error!('There is no junit report to parse') unless File.file?(report_path)

  junit_report = Nokogiri::XML(File.read(report_path))
  failed_tests = []
  passed_tests = []
  suite_name = junit_report.xpath('//testsuite').first['name'].split('.').first
  junit_report.xpath('//testcase').each do |testcase|
    class_name = testcase['classname'].split('.').last
    test_name = testcase['name'].delete('()')

    if testcase.at_xpath('failure')
      failed_tests << "#{suite_name}/#{class_name}/#{test_name}"
    else
      passed_tests << "#{suite_name}/#{class_name}/#{test_name}"
    end
  end

  (failed_tests - passed_tests).uniq
end

desc 'Builds Demo app'
lane :build_demo do |options|
  next unless is_check_required(sources: sources_matrix[:sample_apps], force_check: @force_check)

  scan(
    project: xcode_project,
    scheme: 'DemoAppSwiftUI',
    clean: is_localhost,
    derived_data_path: derived_data_path,
    cloned_source_packages_path: source_packages_path,
    build_for_testing: true,
    devices: options[:device]
  )
end

private_lane :update_testplan_on_ci do |options|
  update_testplan(path: options[:path], env_vars: { key: 'CI', value: 'TRUE' }) if is_ci
end

desc 'Run fastlane linting'
lane :rubocop do
  next unless is_check_required(sources: sources_matrix[:ruby], force_check: @force_check)

  sh('bundle exec rubocop')
end

desc 'Run PR linting'
lane :lint_pr do
  danger(dangerfile: 'Dangerfile') if is_ci
end

def check_foundation_import
  files_missing_imports = []
  Dir.glob("Sources/**/*.swift").each do |file|
    next if file =~ /(StreamNuke|StreamSwiftyGif)/

    files_missing_imports << file unless File.read(file).match?(/import (Foundation|UIKit|SwiftUI|Combine|StreamChat)/)
  end

  unless files_missing_imports.empty?
    UI.error("Files missing 'Foundation' import:")
    files_missing_imports.each { |file| UI.error("- #{file}") }
    UI.user_error!("Lint check failed.")
  end
end

desc 'Run source code formatting/linting'
lane :run_swift_format do |options|
  Dir.chdir('..') do
    check_foundation_import
    strict = options[:strict] ? '--lint' : nil
    sh("swiftformat #{strict} --config .swiftformat .")
    sh("swiftlint lint --config .swiftlint.yml --fix --progress --reporter json") unless strict
    sh("swiftlint lint --config .swiftlint.yml --strict --progress --reporter json")
  end
end

lane :install_runtime do |options|
  install_ios_runtime(version: options[:ios], custom_script: 'Scripts/install_ios_runtime.sh')
end

desc 'Remove UI Snapshots'
lane :remove_snapshots do |options|
  snapshots_path = "../StreamChatSwiftUITests/**/__Snapshots__/**/*.png"
  if options[:only_unchanged]
    pnf_files = git_status(ext: '.png')
    changed_snapshots = (pnf_files[:a] + pnf_files[:m]).map { |f| File.expand_path(f) }
    Dir.glob(snapshots_path).select { |f| File.delete(f) unless changed_snapshots.include?(File.expand_path(f)) }
  else
    Dir.glob(snapshots_path).select { |f| File.delete(f) }
  end
end

lane :sources_matrix do
  {
    e2e: ['Sources', 'StreamChatSwiftUITestsAppTests', 'StreamChatSwiftUITestsApp'],
    ui: ['Sources', 'StreamChatSwiftUITests', xcode_project],
    sample_apps: ['Sources', 'DemoAppSwiftUI', xcode_project],
    ruby: ['fastlane', 'Gemfile', 'Gemfile.lock'],
    size: ['Sources', xcode_project],
    sonar: ['Sources'],
    public_interface: ['Sources']
  }
end

lane :copyright do
  update_copyright(ignore: [derived_data_path, source_packages_path, 'vendor/'])
  next unless is_ci

  pr_create(
    title: '[CI] Update Copyright',
    head_branch: "ci/update-copyright-#{Time.now.to_i}"
  )
end

lane :validate_public_interface do
  next unless is_check_required(sources: sources_matrix[:public_interface], force_check: @force_check)

  # Get branch names
  original_branch = current_branch
  target_branch = ENV['GITHUB_BASE_REF'] || (original_branch.include?('release/') ? 'main' : 'develop')
  UI.important("Target branch: #{target_branch} ðŸ•Šï¸")

  # Run the analysis on the current branch
  sh('interface-analyser analysis ../Sources/ public_interface_current.json')

  # Checkout the target branch
  sh("git fetch origin #{target_branch}")
  sh("git checkout #{target_branch}")

  # Run the analysis on the target branch
  sh('interface-analyser analysis ../Sources/ public_interface_previous.json')

  # Run diff
  report_path = 'interface-analyser-report.md'
  sh("interface-analyser diff public_interface_current.json public_interface_previous.json #{report_path}")

  # Check if report exists and is non-zero in size
  diff =
    if File.exist?(report_path) && File.size(report_path) > 0
      File.read(report_path).strip
    else
      'ðŸš€ No changes affecting the public interface.'
    end

  # Generate markdown table for the PR comment
  header = '## Public Interface'
  content = "#{header}\n#{diff}"

  # Post PR comment if running in CI
  pr_comment(text: content, edit_last_comment_with_text: header) if is_ci

  # Checkout the original branch
  sh("git fetch origin #{original_branch}")
  sh("git checkout #{original_branch}")
end

lane :show_frameworks_sizes do |options|
  next unless is_check_required(sources: sources_matrix[:size], force_check: @force_check)

  sizes = options[:sizes] || frameworks_sizes
  show_sdk_size(branch_sizes: sizes, github_repo: github_repo)
  update_img_shields_sdk_sizes(sizes: sizes, open_pr: options[:open_pr]) if options[:update_readme]
end

lane :update_img_shields_sdk_sizes do |options|
  update_sdk_size_in_readme(
    open_pr: options[:open_pr] || false,
    readme_path: 'README.md',
    sizes: options[:sizes] || frameworks_sizes
  )
end

private_lane :frameworks_sizes do
  root_dir = 'Build/SDKSize'
  archive_dir = "#{root_dir}/DemoApp.xcarchive"

  FileUtils.rm_rf("../#{root_dir}/")

  match_me

  gym(
    scheme: 'DemoAppSwiftUI',
    archive_path: archive_dir,
    export_method: 'ad-hoc',
    export_options: 'fastlane/sdk_size_export_options.plist',
    derived_data_path: derived_data_path,
    cloned_source_packages_path: source_packages_path
  )

  # Parse the thinned size of Assets.car from Packaging.log
  assets_size_regex = %r{\b(\d+)\sbytes\sfor\s./Payload/DemoAppSwiftUI.app/Frameworks/StreamChatSwiftUI.framework/Assets.car\b}
  packaging_log_content = File.read("#{Gym.cache[:temporary_output_path]}/Packaging.log")
  match = packaging_log_content.match(assets_size_regex)
  assets_thinned_size = match[1].to_i

  frameworks_path = "../#{archive_dir}/Products/Applications/DemoAppSwiftUI.app/Frameworks"
  stream_chat_swiftui_size = File.size("#{frameworks_path}/StreamChatSwiftUI.framework/StreamChatSwiftUI")
  stream_chat_swiftui_size_kb = (stream_chat_swiftui_size + assets_thinned_size) / 1024.0

  { StreamChatSwiftUI: stream_chat_swiftui_size_kb.round(0) }
end

lane :size_analyze do
  next unless is_check_required(sources: sources_matrix[:size], force_check: @force_check)

  gym(
    scheme: 'DemoAppSwiftUI',
    configuration: 'Release',
    skip_archive: true,
    skip_package_ipa: true,
    skip_package_pkg: true,
    skip_codesigning: true,
    derived_data_path: derived_data_path,
    cloned_source_packages_path: source_packages_path
  )

  show_detailed_sdk_size(sdk_names: sdk_names, threshold: 42)
end
